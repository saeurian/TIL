# 191219

* 자료구조 : 자료를 저장 및 관리하는 방법
* 알고리즘 : 문제를 해결하는 방법



## 자료구조2

### 시퀀스 자료형

> 리스트, 튜플, range, 문자열데이터와 같이 연속적으로 표현되는 자료형
>
> 사용 방식이 대부분 비슷함

* 특정값 존재 확인

  ``` python
  # 0~90까지 10씩 증가한 값으로 리스트 생성
  a = list(range(0,91,10))
  a
  
  # 시퀀스형에 대해 in 연산자 사용 가능
  30 in a # a 변수(시퀀스형) 안에 30이 있느냐?
  100 in a
  11 not in a
  
  # 기타
  'h' in 'hello, python'
  'h' not in 'hello, python'
  7 in range(100)
  100 in range(100)
  ```

* 자료형 연결

  ```python
  # + 연산자로 시퀀스형에 대한 자료 연결이 가능
  # range는 안됨
  # 다른 형태의 자료형끼리 연결 NO (ex 튜플 + 리스트)
  
  a = [1,2]
  b = [3,4]
  a+b
  'hello'+'hi'
  a = (1,2)
  b = (3,4)
  a+b
  
  # range(0,3) + range(3,5) Error발생
  list(range(0,3)) + list(range(3,5))
  tuple(range(0,3)) + tuple(range(3,5))
  # range(0,3)*3 에러발생
  list(range(0,3))*3
  
  # 다른 자료형 연결 NO
  # list(range(0,3)) + tuple(range(3,5))
  # 'hi' + 7  숫자를 문자로 변경하면 가능 => 같은 type으로 맞춰주기
  'hi' + str(7)
  'hi' + str(3.14)
  ```

* `len()` : 시퀀스 자료형에 해당되는 데이터의 길이 구할 수 있는 함수

  ```python
  a = [1,2,3]
  len(a)
  
  a = (1,2,3)
  len(a)
  
  len(range(0,3))
  len('hello')
  
  hi = '안녕'
  len(hi) # 문자의 개수를 구하는 함수 (bite는 신경쓰지 않음)
  
  hi = '안녕'
  hi.encode('utf-8')
  len(hi.encode('utf-8'))
  ```

> **유니코드**
>
> 전세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준
>
> UTF-8, UTF-16
>
> '유니' : 유니버셜
>
> 1bite 보다 큰 bite 표현 -> 16진수
>
> ```python
> hi = '안녕'
> hi.encode('utf-8')
> len(hi.encode('utf-8'))
> ```

* 자료 참조 

  시퀀스형에 대한 자료 참조는 대괄호 []기호를 사용한다.

  ```python
  x = 'HI HELLO'
  # x[0] -> x.__getitem__(0)
  x[0]
  x[10] -> IndexError
  
  x[len(x)-1]
  x[-1]
  ```

* 슬라이싱

  ```python
  # x[2:-1]
  x
  x[2:-1]
  x[2:]
  x[1:7:2] # index1 부터 2씩 증가하면서 index 6번까지 가져옴
  x[:8:2] # 처음부터 7번까지 2씩 증가하면서 가져옴
  x[3::2] # 3번부터 끝까지 2씩 증가하면서 가져옴
  x[::2] # 처음 부터 끝까지 2씩 증가하면서 가져옴
  x[::] # = x
  
  x[5:1:-1] # 5~2번까지 하나씩 감소하면서 가져옴 5,4,3,2
  x[::-1] # 역순으로 출력
  x[0:len(x)]
  x[:len(x)]
  
  # 튜플도 리스트와 동일
  x=range(10)
  x[4:7]
  list(range(0,7,2))
  
  x = "hello world"
  x[:9:3]
  ```

* 자료 변경 (list)

  ```python
  a = list(range(0,91,10))
  a[1]=11
  a[2:5] = [21,31,'x']	# 영역 지정해서 한번에 변경
  a[1:9:2] = ['a','b','c','d']
  ```

  

### Tuple

> 리스트와 비슷한 자료구조
>
> 리스트 : [] 사용 / 생성, 삭제 수정 가능
>
> 튜플은 () 사용(명시적으로 사용, 괄호를 묶지 않아도 반영되긴 함) / **변경 할 수 없음**

```python
a = (3,2,5,6,1) # 튜플
a
a = 3,2,5,6,1 # 튜플
a

a1 = ()
a1

a2 = 5 # a2는 정수값을 가지고 있는 변수
a2 = 5, # ,를 찍으면 type이 tuple로 인식됨
type(a2)
# 값을 1개 저장한 튜플을 정의할 때는 컴마를 써야함

a3 = ('john', 25, 180.5, True)
a3
# 자료형에 관계없이 저장 가능
# a3[1]=50 에러
# 튜플은 변경이 안되므로, 데이터가 계속 유지되어야 할 경우에 주로 사용

t1 = (1,2,'x','y')
t1
del t1[0]
t1[0]=5
TypeError: 'tuple' object doesn't support item deletion

a = tuple(range(10))
a

# 튜플 <-> 리스트
a = [1,2,3]
a
a = tuple(a)
a
a = list(a)
a
```

** unpaking / paking

``` python
# unpacking : 리스트(튜플)의 요소를 여러개의 변수에 할당하는 것
# packing : 변수에 리스트 또는 튜플을 할당하는 것

a = [1,2,3] # 리스트 패킹
b = (1,2,3) # 튜플 패킹
```

* 슬라이싱, 튜플 연산 (`len() `함수 사용가능)

  ```python
  # 슬라이싱
  t1 = (1,2,'x','y')
  t1[1:]
  
  
  # 연산
  t2 = (3,4)
  t1+t2
  t2*3
  
  # len()
  len(t1)
  ```

* 영역 지정해서 삭제

  ```python
  del a[2:6] # 2번 부터 5번까지 제거
  a
  del a[:5:2] # 0번부터 4번까지 2씩 증가하면서 제거
  a
  ```



### Dictionary

>Key와 Value이 여러쌍으로 구성되어 자료를 표현
>
>다른 언어에서는 맵, 해쉬라고도 부름

* person = [180, 70, 'O', '서울'] << list의 경우
  person2 = {'키':180, '몸무게':70, '혈액형':'0', '사는 곳':'서울'} << dict의 경우
* {}로 묶음 / key : value / ,로 구분
* list와 달리 dict에서는 **그 값이 어떤 것을 의미하는지(Key) 같이 표현**됨
* Key는 변하지 않는 것을 사용
* Value는 변하는 값 / 변하지 않는 값 모두 사용

```python
person = [180, 70, 'O', '서울']
person2 = {'키':180, '몸무게':70, '혈액형':'0', '사는 곳':'서울', '몸무게':80,
           False :0, 99:'구구', 3.14:[3.14,'원주율'],
           '취미':{'오전':'수영', '오후':'공부'}}
# key가 중복되면 마지막 자료가 저장됨
# Value자리에 list, dict, tuple 등 모두 올 수 있음 (key는 NO)
# Key 자리에 문자, 정수, 실수, bullean이 모두 올 수 있음
```

> **Json**
>
> [Python for Data Analysis] p.251
>
> html 문서를 좀 더 가볍고 사용하기 편하게 사용하기 위해 나옴
>
> **xml**
>
> 기존의 html과 같은 marker language, 확장 가능
>
> ** html 문서는 컴퓨터가 그 의미를 알기 힘들게 되어 있음
>
> **csv**
>
> 컴마(,)로 데이터 구분

* dict 생성

  ```python
  ## dict(키1:값1, 키2:값2,....)
  per = dict(height = 180, weight = 70, bt = 'O')
  per
  
  
  ## dict(zip())
  zip(['height', 'weight', 'bt'], [180,70,'O'])
  # (16진수) 짝을 매칭해서 합쳐줌 결과값이 저장되어 있는 메모리 상의 주소
  per = dict(zip(['height', 'weight', 'bt'], [180,70,'O']))
  per
  
  ## dict([(키1,값1),(키2,값2),...]) tuple
  per = dict([('height',180), ('weight',70), ('bt','O')])
  per
  
  ## dict({키1:값1, 키2:값2,...}) dict key ''로 묶어줘야 함
  per = dict({'height': 180, 'weight': 70, 'bt': 'O'})
  per
  ```

* 데이터 추가, 변경 (Key, Value)

  ``` python
  # 딕셔너리['Key'] = 'Value'
  
  a = {'a':[1,2,3]}
  a[2] = 'b' # key:2, value:'b'
  a['name'] = 'hgd'
  a['name'] = 'lss'	# 기존 'name' key에 저장된 값이 변경됨
  a['weight'] = 70.5
  ```

* key와 value 확인

  ```python
  # 딕셔너리 특정 key 확인
  'weight' in a
  'sky' in a
  'sky' not in a
  
  # 특정 key의 value 가져오기
  # 딕셔너리[key]
  a['name']
  
  # 딕셔너리.get('key')
  a.get('name')
  
  ==> a['nn']
  	a.get('nn')
      print(a.get('nn')) # 위와 달리 오류가 뜨지 않고 none으로 뜸
  # 특정 key가 없을 경우 적절한 처리를 해야할 때 .get() 주로 사용
  
  a.get('nn', 'kim')
  # 딕셔너리 a에 nm 키가 없다면, 'kim'을 출력하라는 의미
  # 디폴트(기본값) 설정
  a['id'] = 'test'
  a.get('id', 'guest')
  
  # 딕셔너리 key list 확인 .keys() 함수 사용
  # 딕셔너리 value list 확인 .values() 함수 사용
  # dic_keys, dic_values : type
  a.keys()
  a.values()
  
  # 출력 방법
  # dict_keys(values) => list로 변경해서 참조
  list(a.keys())
  list(a.values())
  
  # for문 이용해서 key(values) 출력
  for k in a.keys():
      print(k)
  for v in a.values():
      print(v)
      
  # 딕셔너리 길이 구하기 - key의 개수
  len(a)
  
  # key와 value tuple형태로 동시에 출력
  
  for i in a.items():
      print(i)
  ```

### Set

> 집합
>
> {}로 표현됨 (dict랑 구분 필요)
>
> x = {1,1,2,2,3} => x={1,2,3}

* 특징

  1. 중복을 허용하지 않는 자료구조

  2. 순서가 없음 (저장순서 보장 X)

     ```python
     s2[1] # 1번의 값이 꼭 항상 같은 그 값이라고 보장할 수 없음
     # list로 변경해서 참조 가능 (tuple도)
     s = set(['k', 'i', 'm'])
     slist = list(s)
     slist
     slist[1]
     
     stuple = tuple(s)
     stuple
     stuple[1
     ```

  3. 집합 연산 가능

     ```python
     # 교집합
     s1 & s2
     s1.intersection(s2) 
     #.intersection(연산하고자 하는 set name)
     # 위치를 바꿔도 동일한 결과
     
     # 합집합
     s1 | s2
     s1.union(s2)
     
     # 차집합
     s1 - s2
     s1.difference(s2)
     ```

* 데이터 추가

  ```python
  #.add() : 데이터 추가 함수
  # 요소 하나만 추가 가능 / 2개 이상 추가 안됨
  # list 형식 추가 불가
  s = set([1,2])
  s.add(3)
  s.add([4,5]) >> Error
  
  # .update() : 데이터 추가 함수
  # 2개 이상도 한번에 추가 가능
  s.update([4,5])
  s
  ```



## 조건문

### 자료구조 참, 거짓

> 무언가가 있으면 참,
> 아무것도 없으면 거짓
>
> 참 : "test", [1,2], (1,2), {1,2}, 1(0 외의 모든 수 참) 
> 거짓 : "", [], (1,2). {}, 0, None

### if 구문

> if 조건 :
> 종속(들여쓰기 X : if문과 다른 문장으로 봄)
>     종속절(들여쓰기 : if문에 종속된 문장으로 판단)
>
> **따라서 들여쓰기 꼭 주의!!**
>
> 조건절이 참일 때, 종속절 수행

```python
x = 10
if x == 10:
    print("10입니다")
    print("5보다 큽니다")
print("문장을 수행합니다")

# 비교할 때는 == 기호를 사용해줘야 함 =는 변수 지정

# 참 : "test", [1,2], (1,2), {1,2}, 1(0 외의 모든 수 참) 
# 거짓 : "", [], (1,2). {}, 0, None

if [1,2] :
    print('수행합니다')

if None:
    print('수행합니다')
```

* if 문 작성 시 주의할 점

  1. : 기호 생략

  2. 들여쓰기

  3. 실행할 문장이 없을 때는 `pass` 입력

     ```python
     x = 10
     if x == 10:
         pass
     print('안녕')
     ```

  4. 종속절 들여쓰기 수준을 맞춰 줘야함 (IndentationError)

     ```python
     x = 10
     if x == 10:
         print('안녕')
         if x % 2 == 0:
             print('하세요')
     ```

* if문 중첩 사용

  ```python
  x = 5
  if x >= 3 :
      print('3 이상')
      if x<10:
          print("10 미만")
      if x<5 :
          print("5 미만")
  print("입니다")
  ```

  - `else`

    ```python
    if []: # 거짓이므로 else 문장 수행
        print('참')
    else:
        print("거짓")
        
    if [1,2]: # 참이므로 if 문장 수행
        print('참')
    else:
        print("거짓")
        
    if None : # 거짓이므로 else 문장 수행
        print('참')
    else:
        print("거짓")
    ```

### bool()

> 참 거짓 판별 시 사용하는 함수

```python
bool(0)
bool(10)
bool('python')
bool('')
```

### while 문

> while (~동안)
>
> 지정한 조건이 참인 **동안**에 계속 반복
>
> while 조건 :
>
> ​	종속절

```python
a = [1,2,3]
while a :
    print(a.pop())
```

