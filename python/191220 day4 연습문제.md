#### sub Q1.

동일한 수가 발생하지 않도록 로또생성기 만들기

```python
i = set() # 중복을 방지 위해서 빈 set 생성
while len(i) <= 6 : # i 요소 개수가 6개가 될 때까지 실행
    r_int = random.randint(1,45)
    i.add(r_int) # 1~45 에서 생성된 난수를 set에 add
print(i)
```



#### sub Q2.

잔액이 200원 미만이면 판매가 안되도록...

```python
coffee = 10 # 10잔 커피, 1잔 200원
money = 1100 # 1000원

while money :
    print("커피가 나옵니다")
    coffee = coffee - 1
    money = money - 200
    print("남은 커피는 %d잔 입니다" % coffee)
    print("남은 잔액은 %d원 입니다" % money)
    if coffee == 0:
        print("커피가 떨어졌습니다 [판매중지]")
        break
    if money < 200: # money가 200 미만으로 떨어지면 break걸기
        print("돈이 부족합니다 [구매불가]")
        break
```



### sub Q3.

밑의 모양 출력

```python
"""
  *
 ***
*****
"""
```

```python
k = int(input('층 수 : '))

for i in range(1,k+1):
    print(' '*(k-i) + '*'*(2*i-1))
    
# 각각의 층은 전체 층 수에서 별 갯수를 제외한 만큼 공백이 필요 = ' '* (k-i)
# for 문의 i는 각각의 층 수를 의미 k는 전체 층 수 의미
# *은 각각의 층에서 2n-1 일반식 계산을 한 것 만큼 출력
```



#### Q1.

밑의 모양 출력 1차원의 점들이 주어졌을 때, 그 중 가장 거리가 짧은 것의 쌍을 출력하는 함수를 작성하시오. (단 점들의 배열은 모두 정렬되어있다고 가정한다.) 예를들어 S={1, 3, 4, 8, 13, 17, 20} 이 주어졌다면, 결과값은 (3, 4)가 될 것이다.

```python
# lambda 쓰는 방식

# 기초 작업 (빈 리스트 생성, 주어진 점 배열 list로 변경)
S={1, 3, 4, 8, 13, 17, 20}
dis_l = []
S_list = list(S)

# 점 배열 list에서 거리(dis) 계산하여 tuple형태로 dis_l 리스트에 추가
for i in range(len(S_list)):
    for j in range(len(S_list)):
        if i == j : pass
        else : 
            dis = abs(S_list[i] - S_list[j])
            dis_l.append((S_list[i], S_list[j], dis))

# dis_l 리스트에서 index 2에 있는 거리 값으로 오름차순 정렬
dis_l.sort(key = lambda element:element[2])

# 정렬된 리스트의 맨 앞 index 0 번째가 가장 거리가 짧은 쌍이므로 점 배열을 (3,4)형태로 출력
dis_l[0]
print((dis_l[0][0],dis_l[0][1]))
```

```python
# lambda 안 쓰는 방식

# 기초 작업 (빈 리스트생성, 주어진 점 배열 list 로 변경)
S={1, 3, 4, 8, 13, 17, 20}
dis_l = [] # 점 사이의 거리 리스트
point = [] # 두 점
S_list = list(S)

for i in range(len(S_list)):
    for j in range(len(S_list)):
        if i == j : # 자기자신끼리 계산은 pass
            pass
        elif (i == 0) and (j == 1): # 맨 첫번째 계산은 비교하지 않고 점 사이의 거리, 두 점 리스트에 append
            dis = abs(S_list[i] - S_list[j])
            dis_l.append(dis)
            point.append((S_list[i],S_list[j]))
        else :
            vs_dis = abs(S_list[i] - S_list[j]) # dis_l[0]에 있는 거리와 비교하여 더 작으면 dis_l[0] 자리에 대신 들어감 / 점 쌍은 point[0]에 대신 들어감
            if vs_dis < dis_l[0]:
                dis_l[0] = vs_dis
                point[0] = ((S_list[i],S_list[j]))

# 즉, dis_l[0], point[0]에는 점 사이의 거리를 비교해서 작으면 넣고 아니면 넣지 않았기 때문에 항상 가장 작은거리와 그에 해당하는 점이 남아있게 됨
print(point[0])
```



#### Q2.

주어진 문자열(공백 없이 쉼표로 구분되어 있음)을 가지고 아래 문제에 대한 프로그램을 작성하세요. data="이유덕,이재영,권종표,이재영,박민호,강상희,이재영,김지완,최승혁,이성연,박영서,박민호,전경헌,송정환,김재성,이유덕,전경헌"



2-1.

김씨와 이씨는 각각 몇 명 인가요? "이재영"이란 이름이 몇 번 반복되나요? 중복을 제거한 이름을 출력하세요. 중복을 제거한 이름을 오름차순으로 정렬하여 출력하세요.

```python
data="이유덕,이재영,권종표,이재영,박민호,강상희,이재영,김지완,최승혁,이성연,박영서,박민호,전경헌,송정환,김재성,이유덕,전경헌"

# 김씨와 이씨 list 생성, str형태의 data를 컴마 기준으로 split하여 list로 변경
kim = []
lee = []
data_list = data.split(',')

# for 문 이용하여 이름을 하나하나 뽑은 후 그 이름을 list로 만들어 j[0]으로 '성'추출
# 성이 '김', '이'냐에 따라 각각의 리스트에 append 되도록 함
for i in data_list:
    j = list(i)
    if j[0] == '김':
        kim.append(i)
    elif j[0] == '이' :
        lee.append(i)
        
# 답변 출력
print('A1. 김씨는 {0}명, 이씨는 {1}명 입니다.'. format(len(kim), len(lee))
```



2-2.

이재영이라는 이름이 몇번 반복되나요?

```python
# str형태의 data를 컴마 기준으로 split하여 list로 변경
# 리스트에 이재영 이름을 기준으로 count하여 그 결과를 출력
data_list = data.split(',')
lee_c = data_list.count('이재영')
print('A2. "이재영"이라는 이름은 {}번 반복됩니다.'.format(lee_c))
```



2-3.

중복을 제거한 이름을 출력하세요.

```python
# set() 자료형을 이용하여 중복 제거
data_s = set(data_list)
print(data_s)
```



2-4.

중복을 제거한 이름을 오름차순으로 정렬하여 출력하세요.

```python
# sorted 함수를 이용하여 오름차순으로 정렬하여 출력
data_sort = sorted(data_s)
print(data_sort)
```



#### Q3.

10미만의 자연수에서 3과 5의 배수를 구하면 3,5,6,9이다. 이들의 총합은 23이다. 1000미만의 자연수에서 3,5의 배수의 총합을 구하라.

```python
total = 0

# 3,5의 배수를 구하여 total 변수에 더해주는 과정
for i in range(1,1000) :
    if i % 3 == 0 : # 3의 배수를 구하는 과정
        total += i
    elif i % 5 == 0 : # 5의 배수를 구하는 과정
        total += i
    else:
        pass
    
print(total)
```



#### Q4.

자기 자신을 제외한 모든 양의 약수들의 합이 자기 자신이 되는 자연수를 완전수라고 한다. 예를 들면, 6과 28은 완전수이다. 6=1+2+3 // 1,2,3은 각각 6의 약수 28=1+2+4+7+14 // 1,2,4,7,14는 각각 28의 약수 입력으로 자연수 N을 받고, 출력으로 N 이하의 모든 완전수를 출력하는 코드를 작성하라.

```python
# 기초 작업 (input, 빈 리스트 생성)
N = int(input('자연수를 입력하세요 : ' ))
div = []
num = []

# 약수들의 리스트 div를 만들고 그것을 모두 더한 값(total)을 자기 자신과 비교하여 같으면 완전수 리스트(num)에 추가
for j in range(1,N+1):
    total = 0
    div = []
    for i in range(1,j):
        if j%i == 0 :
            div.append(i) # j 의 약수 리스트
    for a in div: # 약수 리스트의 수 모두 더함 = total
        total+=a
    if total == j : # 약수의 합과 자기자신(j)가 같은지 확인 후 완전수 리스트에 추가
        num.append(j)
    

print(num)
```



#### Q5.

'0-9'까지의 문자로 된 숫자를 입력 받았을 때, 이 입력 값이 '0-9'까지의 숫자가 각각 한번 씩만 사용된 것인지 확인하는 함수를 구하시오.

sample inputs: 0123456789 01234 01234567890 6789012345 012322456789 sample outputs: true false false true false

```python
num = input('0-9 숫자입력 ; ')

# 0~9까지의 수 중 입력 받은 수 num에서 count 했을 때, 없거나 중복이 생기면 False출력하고 break 이외의 경우 True출력
for i in range(0,10) :
    if num.count(str(i)) > 1 or num.count(str(i)) == 0:
        print('False')
        break
    elif i == 9:
        print('True')
```



#### Q6.

run length 문자열을 입력받아서, 같은 문자가 연속적으로 반복되는 경우에 그 반복 횟수를 표시하여 문자열을 압축하기.

```python
# 문자열 입력 받은 후 중복이 없는 리스트와 중복이 있는 원본 리스트 생성
text = input('문자열 입력 : ')
text_l = list(text)
text_s = sorted(list(set(text_l))) # 오름차순으로 리스트를 정리하여 출력 시 깔끔해보이게..


# 중복이 없는 리스트가 기준이 되어 원본 리스트에 count해보고 결과를 해당 문자와 합쳐 출력
for i in text_s :
    ct = text_l.count(i)
    ct_n = i + str(ct)
    print(ct_n, end = '')
```

