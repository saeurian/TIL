# 191227 파이썬 기초7 (내외장함수, 정규표현식)



## 내장함수 (191226에 이어서)



### map 함수 사용 시 주의할 점

```python
target = [1,2,3,4]
res = []
def add1(n):
    return n+1
for v in target :
    res.append(add1(v))
print(res)

# map함수 이용
print(list(map(add1, target)))
print(list(map(lambda x:x+1, target)))

print(list(map(str, target)))
# 람다 함수는 두고두고 쓸 수 없음 한번만 쓰고 버리는 용도
# def로 정의한 함수는 계속적으로 사용 가능
```



### `filter()`

> 반복가능 자료형 요소가 첫번째 인수이니 함수에 입력이 되었을 때,
>
> 변환 값이 참인 경우에 대해서만 필터링해주는 함수

```python
# filter함수 없이 양수만 필터링해주는 함수 구현
def positive(p):
    res = []
    for i in p :
        if i>0:
            res.append(i)
    return res
print(positive([1,-3,2,-5]))

# filter함수 사용
print(list(filter(lambda x:x>0, [1,-3,2,-5]))) # list로 변환 후 출력

target = list(range(1,11))
res = []

def is_even(n):
    return True if n%2 == 0 else False

# filter
res = list(filter(is_even, target))

# for문
for v in target :
    if is_even(v) :
        res.append(v)
print(res)

# filter+lambda 조합
res = list(filter(lambda x : x %2 == 0 , target))
print(res)

# [1,3,-2,-5] 양수만 필터링
print(list(filter(lambda x : x>0, [1,3,-2,-5])))
```

### `hex()`

> 정수 -> 16진수

```python
hex(254)

print => '0xfe'
```

### `id()`

> id(객체)의 메모리 주소값을 돌려주는 함수

```python
a = 3 # 3이 저장된 주소를 a가 갖고 있다는 의미
print(id(3))
print(id(a))
```

### `int()`

> 정수로 변경

```python
int('3')
int(3.14)
int("101",2) # 2진수 101에 대한 10진수 값
int("FA",16) # 16진수 FA에 대한 10진수 값
```

### `isinstance()`

> ** 보통 is로 되는 함수는 True or False로 나옴
>
> 이 객체가 이 클래스에서 나온 것이 맞는지 확인
>
> 붕어빵 isinstance 붕어빵기계 => True
>
> 꽃게빵 isinstance 붕어빵기계 => False

```python
class 붕어빵기계:
    pass
class 꽃게빵기계:
    pass
꽃게빵 = 꽃게빵기계()
붕어빵 = 붕어빵기계()
print(isinstance(붕어빵, 붕어빵기계))
print(isinstance(꽃게빵, 붕어빵기계))
```

### `min()`& `max()`

> min() : 최솟값
>
> max() : 최댓값

```python
max([1,2,3])
max('test') # 아스키 코드 값이 가장 큰 문자 (알파벳 뒤로 갈수록 아스키코드값이 큼)

max([1,2,3])
min('test')
```

### `oct()`

> 8진수로 바꿔줌

```python
oct(8) # 10진수 8 -> 8진수 10
```

### `chr()`& `ord()`

> chr() : 아스키코드 -> 문자
>
> ord() : 문자 -> 아스키코드

```python
chr(97) # ord함수의 반대
ord('a')
```

### `pow()`

> 제곱

```python
pow(2,4)
```

### `round()`

> 반올림 함수

```python
round(4.6)
round(3.4567,2) # 자리수 지정 소수 둘째자리까지
```

### `sort()` & `sorted()`

> list.sort() : 리스트를 정렬, 반환값은 None / 원본 list의 순서 변경
>
> sorted(list) : 정렬된 새로운 리스트 반환 / 원본 list에는 영향 없음

```python
li = [1,3,2]
li.sort() => 값  None
li

li2 = [1,3,2]
print(sorted(li2))

# 속도 : sort > sorted sorted 사본 리스트가 생성
```

### `str()`

> 문자열로 변환

```python
str(3)
str("hi")
str("hi".upper()) # 대문자
```

### `sum()`

> 자료형 안의 인수를 모두 더해줌

```python
sum([1,2])
sum((1,2,3)) # tuple도 가능
```

### `zip()`

> 자료를 묶어주는 함수

```python
list(zip('abc', 'def'))
list(zip('abc', 'defg'))
list(zip('abc', 'de'))
# 짝이 맞는 부분까지만 묶어짐

# 3개 이상 구성도 가능
list(zip('abc', 'def', 'ghi'))
```



## 외장함수

### pickle

> 객체 상태 그대로 저장 / 불러오기 모듈

#### 파일 저장

```python
import pickle
f = open('test.txt', 'wb') # 객체형태로 지정할 때 binary 모드
data = {1: 'python', 2: 'java'} # dict
pickle.dump(data, f)
f.close()

# dict 객체 그대로 저장함
```



#### 파일 불러오기

```python
f = open('test.txt', 'rb')
data = pickle.load(f)
print(data)

# 저장된 객체 그대로 read
```



### shutil

> 파일복사 모듈

```python
shutil.copy("test.txt", "test2.txt")
```



### glob

> 특정 폴더 파일 목록을 모두 뽑아오는 것

```python
import glob
glob.glob("c:\da\*")
glob.glob("c:\Windows\*.log") # 확장자 지정
```



#### webbrowser

> 웹 브라우저 오픈

```python
import webbrowser
webbrowser.open('http://www.goolge.com')
webbrowser.open_new('http://www.goolge.com')
```



## 두 점 사이의 거리 구하기

```python
# 2차원 평면에서 위치를 나타내는 클래스
import math
class Point2D :
    def __init__(self, x, y):
        self.x = x 
        self.y = y
        
p1 = Point2D(30,20) # 점 1 (x = 30, y = 20)
p2 = Point2D(50,40) # 점 2 (x = 50, y = 40)
print("p1:{} {}".format(p1.x, p1.y))
print("p1:{} {}".format(p2.x, p2.y))

# 두 점 사이의 거리 출력 (피타고라스 정리)
dis = ((p1.x-p2.x)**2 + (p1.x-p2.x)**2)**0.5
dis2 = math.sqrt(pow(p1.x-p2.x,2) + pow(p1.x-p2.x,2)) # math 모듈 사용
print(dis)
print(dis2)
```



## Iterator

> 반복자
>
> 데이터를 차례대로 꺼낼 수 있는 객체

for i in range(10)
-> 숫자 0~9까지를 차례대로 꺼내는 이터레이터가 있음 이터레이터에 의해서 0~9까지의 수가 생성

* iterable : 반복 가능한 객체 ex ) 문자열, 리스트, 튜플...

### `dir()`

> 반복가능한 객체인지 확인 가능

```python
# 데이터가 이터러블 한지 확인
# dir(객체)
dir([1,2,3]) # 반복가능 : __iter__이 포함
[1,2,3].__iter__() # iterator 객체 출력
```



### `__iter__`를 이용하여 출력

```python
it = [1,2,3].__iter__()
print(it.__next__())
print(it.__next__())
print(it.__next__())
# it안에 들어있는 요소 수 만큼 next 실행 가능

for i in range(1,4):
    print(i)
# 위와 같른 구문
```



### 구현 순서

```python
"""
1) __iter__() 호출
2) __next__() 호출 -> i 변수에 0 저장 -> 프린트
3) __next__() 호출 -> i 변수에 1 저장 -> 프린트
4) __next__() 호출 -> i 변수에 2 저장 -> 에러발생 stop
"""
for i in range(3):
    print(i)
```





## 정규표현식(re)

> 문자열을 규칙에 맞춰 정리한 것

데이터수집 (정규표현식) -> 전처리 -> 분석

### re

> regular express 정규표현식 모듈

정규표현식 예시

```python
data = """
kim 950101-1234567
lee 970202-2345678
"""
result = []
word_res = []
for line in data.split('\n'):
    word_res = []
    for word in line.split(" "):
        if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit() : # isdigit() : 숫자인지 아닌지 확인해줌
            w = word[0:6] + "-" + "*******"
            word_res.append(w)
    result.append(" ".join(word_res))
            
print("\n".join(result))

# 정규표현식 사용시

import re
# regular express 정규표현식 모듈

data = """
kim 950101-1234567
lee 970202-2345678
"""

pattern = re.compile("(\d{6})[-]\d{7}")
print(pattern.sub("\g<1>-*******",data))
```



### 정규 표현식 작성방법

#### `match()` 

> re.match("패턴", "문자열")
>
> 주어진 문자열에 지정한 패턴이 있는징 여부를 확인

```python
print(re.match("hello", "hello.world"))
print(re.match("hi", "hello.world"))
# None이 나오면 패턴이 없는 것

print(re.match("[0-9]", '123'))
# 패턴이 문자열에 있는지 확인
# span = (0,1)패턴이 매치되는 문자열의 위치
```



#### 정규표현식 메타문자

>문자의 본래 의미가 아닌, 특정 의미를 갖는 문자
>
>() {} [] \ | ? + * $ ^ ...

1. [ ] : 문자와 관련된 정규식 사용 / [] 사이에는 어떤 문자도 올 수 있음

   ex) 정규표현식 : [abcdef] => 의미 : abcdef 여섯개의 문자 중에서 한개의 문자와 매치

   ​	"a"는 정규식에 일치하는 문자가 있으므로 -> 매치됨

   ```python 
   # [] 예시
   print(re.match("[abcdef]", "a")) -> match
   print(re.match("[abcdef]", "z")) -> None
   print(re.match("[abcdef]", "all")) -> match
   print(re.match("[abcdef]", "sky")) -> None
   print(re.match("[abcdef]", "best")) -> match
   print(re.match("[abcdef]", "fgha")) -> f만 match 되어 나옴
   
   print(re.match("[a-z]", "fgha"))
   print(re.match("[a-z]", "ABC"))
   # [a-z] : 알파벳 소문자 모두
   print(re.match("[A-Z]", "ABC"))
   # [A-Z] : 알파벳 대문자 모두
   print(re.match("[a-zA-Z]", "abc"))
   # [a-zA-Z] : 알파벳 대소문자 모두
   
   print(re.match("[0-9]", "119"))
   # [0-9] : 숫자 모두
   print(re.match("\d", "119"))
   # \d : 숫자와 모든 수 [0-9]와 같은 의미
   print(re.match("[^0-9]", "119"))
   # [^0-9] : 숫자를 제외한 모두
   print(re.match("\D", "119"))
   # \D : 숫자가 아닌 모든 것과 매치 [^0-9]와 같음
   
   print(re.match("\w", "test"))
   print(re.match("[0-9a-zA-Z]", "test"))
   # \w : 영문자 숫자 모두 매치 = [0-9a-zA-Z]
   
   print(re.match("\W", "test"))
   print(re.match("[^0-9a-zA-Z]", "대한민국"))
   # \W, [^0-9a-zA-Z] : 영문자, 숫자 외에 모두 매치
   
   print(re.match("[가-핳]", "대한민국"))
   # [가-핳] : 한국어 전체 매치
   ```

2. ^문자열 : 문자열이 맨 앞에 오는지 판단

   문자열$ : 문자열이 맨 뒤에 오는지 판단

   search 함수에서 사용

   ```python
   print(re.search("^hi", "hello.hi")) -> None
   # hi문자열이 맨 앞에 오는지 판단
   print(re.search("hi$", "hello.hi")) -> match
   # hi문자열이 맨 뒤에 오는지 판단
   ```

3. | 문자열 : bar "또는"의 의미

   ```python
   print(re.match("hello|hi|good", "hi"))
   ```

4. `*` : 문자열이 0개 이상 있는지 판단

   ```python
   print(re.match("[0-9]*", '123'))
   # *은 숫자가 0개 이상 있는지 판단 (있을 수도, 없을 수도)
   # 위 코드에서는 숫자 3개가 매치됨
   print(re.match("[0-9]*", '12a3')) # 숫자 2개 매치
   print(re.match("[0-9]*", 'x12a3')) # 0개 매치
   
   print(re.match('a*', "aaab"))
   print(re.match('a*b', "b"))
   # a가 0개 이상 있으면서 b로 이어진다면 매치
   ```

5. `+` : 문자열이 1개 이상 있는지 판단

   ```python
   print(re.match("[a-z]+", "12a3bc")) -> None
   print(re.match("[a-z]+", "abc123def")) -> abc123def
   # + : 문자가 1개 이상 있는지 판단
   
   print(re.match('a+b', "b"))
   print(re.match('a+b', "ab"))
   print(re.match('a+b', "aab"))
   print(re.match('a+b', "aacb")) -> None
   ```

   ** 꼭! **패턴에 대해서** 문자열이 만족을 해야함

6. ? : 문자가 0개 또는 1개가 있는지 확인

   ```python
   print(re.match("h?", "h"))
   print(re.match("h?", "hi"))
   print(re.match("h?", "hello"))
   print(re.match("h?", "ello"))
   # ?는 문자가 0개 또는 1개가 있으면 매치됨
   # h?는 h문자가 0개 또는 1개가 있으면 매치됨
   ```

7. `.` : 문자가 1개 있으면 매치

   ```python
   # h.은 h문자 다음에 문자가 1개 있으면 매치됨
   print(re.match("h.", "h")) -> None
   print(re.match("h.", "hello"))
   print(re.match("h.l", "hello")) # h+문자+ㅣ모양이 나와야 함
   
   print(re.match("a.b", "ab")) -> None
   # a, b사이에 문자가 없어서
   print(re.match("a.b", "acb"))
   print(re.match("a.b", "accb")) -> None
   # a,b사이에 문자가 1개보다 많이 있어서
   ```

8. 문자{횟수} : 문자가 횟수만큼 있는지 확인

   문자열도 가능 (문자열){횟수} : 문자열이 지정된 횟수만큼 반복되는지 확인

   ```python
   # a{3} : a가 3개 있는지 확인
   print(re.match("a{3}", "aaabbbccc"))
   print(re.match("a{3}b", "aaabbbccc"))
   print(re.match("a{3}b*", "aaabbbccc"))
   print(re.match("a{3}b+", "aaabbbccc"))
   print(re.match("a{3}b+c", "aaabbbccc"))
   print(re.match("a{3}b+c*", "aaabbbccc"))
   
   print(re.match("a{3}", "aabbbccc")) -> a가 두개밖에 없음 None
   
   # (문자열){횟수}
   print(re.match("hi{2}","hi")) # h+i2번 나와야 함 -> None
   print(re.match("(hi){2}", "hi")) # hi가 2번 나와야 함 -> None
   print(re.match("(hi){2}", "hihi"))
   ```

* 정규표현식 실제 표현 방법

  ```python
  # 주의 사항 a[.]b = a + . + b
  "[a-z]+[.][a-z]+[.]+com"
  print(re.match("[a-z]+[.][a-z]+[.]+com", "test.abc.com"))
  
  tel1 = "010-1234-5678"
  tel2 = "02-1234-5678"
  print(re.match("[0-9]{3}-[0-9]{4}-[0-9]{4}",tel1))
  print(re.match("[0-9]{3}-[0-9]{4}-[0-9]{4}",tel2))
  print(re.match("[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}",tel2))
  # {2,3} 숫자가 최소 2개 ~ 최대 3개 매치될 수 있음
  
  jm = "990101-1234567"
  check = re.match("[0-9]{6}-[0-9]{7}", jm)
  if check :
      print("정상번호")
  else : 
      print("비정상번호")
  ```

  



