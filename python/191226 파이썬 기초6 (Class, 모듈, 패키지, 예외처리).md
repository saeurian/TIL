# 191226 파이썬 기초6 (Class, 모듈, 패키지, 예외처리)



## 함수를 만들어 반복문안에 사용할 때

함수 안에서 반복문이 나오는 것이 낫다

함수가 여러번 반복되는 것은 연산을 느리게 함



## Class

> 객체를 표현하기 위한 개념
>
> EX)
>
> 게임에서 기사, 궁수, 마법사 등 직업별로 클래스가 생성됨
>
> 웹브라우저 - 스크롤바, 버튼, 체크박스 등 구성요소 모두 클래스임

### 만드는 과정

클래스는 속성과 메서드로 구성됨

1. 기사 클래스로 홍길동 객체(캐릭터)를 생성
2. 체력, 마나, 공격력 ... 초기값 설정 - 속성
3. 달리기, 베기, 찌르기 ... 동작 설정 - 메서드



### 계산기 만들기

```python
class FourCal():
     def setData(self, first, second):
            # 여기서 self 는 밑의 a를 의미
            self.first = first # self.first=4 first는 임시변수 같은 것
            self.second = second # self.first=2
     def add(self):
         res = self.first + self.second
         return res
     def sub(self): # self에는 first와 second가 정의되어 있음
         res = self.first - self.second
         return res
     def div(self):
         res = self.first / self.second
         return res
     def mul(self):
         res = self.first * self.second
         return res
       
 # 사칙 연산 클래스
a = FourCal() # FourCal 이라는 class로 부터 객체 생성(a)
a.setData(4,2) # 숫자 4, 2를 a에 지정
print(a.mul()) 
print(a.add()) # 4+2 = 6 리턴
print(a.sub()) 
print(a.div())  
```



### Class 상속

class 자식클래스명(부모클래스명):

자식 클래스는 부모클래스의 모든 기능을 사용할 수 있음 & 기능 변경 추가 가능

```python
class MoreFourCal(FourCal):
     pass
    
b= MoreFourCal()
b.setData(4,2)
print(b.mul()) 
print(b.add())
print(b.sub()) 
print(b.div())  
```

* 기능 추가

  ```python
  class MoreFourCal(FourCal):
      def setData(self, first, second):
              # 여기서 self 는 밑의 a를 의미
              self.first = first # self.first=4 first는 임시변수 같은 것
              self.second = second 
      def pow(self):
          res = self.first ** self.second # 제곱연산
          return res
      
      b= MoreFourCal()
  b.setData(4,2)
  print(b.pow())
  ```

* 메서드 오버라이딩(overriding)

  부모클래스로부터 상속받은 메서드를 자식이 변경한 것

  ```python
  class SafeFourCal(FourCal):
      def div(self): # self 무조건 필수 (FourCal의 div함수를 변경)
          if self.second == 1:
              print("1로 나누지 마세요")
              return 
          else:
              return self.first/self.second
          
  sfc = SafeFourCal()
  sfc.setData(4,1)
  print(sfc.div())
  ```



### 변수 여러개 받기 *args

```python
class Person():
    def __init__(self, *args): # *args : 인수가 여러개 들어올 수 있음
        self.name = args[0]
        self.age = args[1]
        self.addr = args[2]
    def greeting(self):
        res = "안녕하세요. 나는 {}입니다.".format(self.name)
        return print(res)
    
ps = Person("홍길동", 25, "서울시 역삼동")
ps.greeting() # 안녕하세요. 나는 홍길동입니다.
print("이름:", ps.name)
print("나이:", ps.age)
print("사는곳:", ps.addr)
```



## Pycharm

### 설치

이전에 아나콘다로 깔았던 python은 가상 환경

pycharm은 가상환경이 아닌, 로컬에 설치하는 것

1. python을 따로 로컬에서 다운로드 받거나
2. 아나콘다 python을 이용할 수 있음 < 수업에서는 2번 이용

[pycharm 다운로드](https://www.jetbrains.com/pycharm/)에서 다운받아 설치 (community 버전 다운)

시작에서 pycharm 들어가서 테마 등 옵션을 선택하고 next눌러주기

기본으로 아나콘다의 python을 선택함 -> interpretor를 바꿔주면 다운받은 python을 선택할 수 있음



### jupyter notebook 과 호환

jupyter notebook > save as 메뉴에서 .py 파일로 저장 후 오픈 가능

pycharm > 설정 > Project interpreter에서 아나콘다 환경으로 변경하면 pycharm에서 아나콘다의 패키지를 사용할 수 있음



### jupyter notebook 과 다른점

debug 모드를 이용해서 어디서 오류가 나는지 check 지점을 설정하고 확인할 수 있음

프로그래밍하기에 편함

결과를 보려면 print를 꼭 입력해줘야 함



## 모듈(module)

> 함수나 변수, 클래스들을 모아놓은 파일
>
> 다른 파이썬 프로그램에서 모듈을 사용하기 편하게 하기 위해서
>
> 확장자 .py가 붙은 파일

### 문법

단, 불러올 때 모듈파일이 같은 폴더 안에 있어야 함

1. 해당 파일이 같은 경로에 있는 경우
2. extend library 에 있는 기본적으로 사용할 수 있는 파일

위의 두 경우는 바로 import 가능

모듈에는 1개 이상의 함수, 변수, 클래스 등이 올 수 있다.

```python
import 모듈이름
모듈이름.함수이름()

# 함수를 바로 불러올 때
# from 모듈이름 import 모듈함수
from mod1 import add
print(add(1,3))

# 모든 함수를 다 쓰고 싶을 때 * 활용
from mod1 import *
print(sub(1,2))
```



### Main module

main module의 내용 main module에서만 시랭하는 방법

```python
if __name__== "__main__":
    print(add(2,3))
    print(sub(4,2))
# mod1에서 mod1(main)을 실행할 때 if부분을 실행
# 즉 해당파일에서만 동작이 실행하도록 해줌

__name__== "__main__"을 사용하면
__name__== "__main__" 조건이 참이됨
따라서 if 문에 있는 문장을 수행
그런데, 외부 파일에서 이 모듈을 불러와 실행할 때는 __name__!= "__main__"이므로
if문이 실행이 안됨
```



## 패키지(package)

파이참 > New > Python package 에서 생성 가능

### 문법

```python
# case1
# import 패키지명.모듈명
import pack1.pack_first
# 패키지명.모듈명.함수명()
pack1.pack_first.prn()

# case2
# from 패키지명.모듈명 import 함수
from pack1.pack_first import prn
# 함수
prn()

# case3
# from 패키지명 import 모듈명
from pack1 import pack_first
# 모듈명.함수명
pack_first.prn()
```



## 예외처리(try)

> 예외 상황이 발생했을 경우를 미리 대비하여 어떻게 처리할 지 미리 정해두는 것

* 예외상황 예시

  1. 없는 파일이거나 (다른 곳으로 파일 이동)

     ```python
     f = open("없는파일.txt", "r")
     ```

  2. 연산과정에서 0이 와서 0으로 나누게 되거나 (ZeroDivisionError 발생)

     ```python
     print(2/0) # ZeroDivisionError 발생
     ```

### `try- except` 문법

try : 기본 시행문장 / except : 오류발생 시 시행문장

```python
try :
    print(2/0)

# print(2/0) 문장을 수행하는 과정에서 예외상황이 발생한 경우
# 만약 ZeroDivisionError 예외상황이면
# 아래와 같은 문장을 수행해라
except ZeroDivisionError as e :
    print("{} | 0으로 나누시면 안됨".format(e))
```



## 내장, 외장 함수

### 내장함수

> import 가 필요 없음

#### `abs()`

​	절대값 출력

```python
print(abs(-3))
```

#### `all()`

​	모든 입력값이 참일 때 참인 함수

```python
all([-1,1,2,-2]) # 모두 참일 때 참이 됨
# 0 :  거짓 / 0이 아닌 숫자는 모두 참
all([-1,0,1])
```

#### `any()`

​	값  중 하나라도 참이면 참을 출력

​	모든 값이 False여야 False를 출력 함

```python
any([1,2,3,0]) 
# 하나라도 참이면 참 출력
# 모두 거짓인 경우에만 거짓 출력
any([0,0])
any(["",None])
```

#### `chr()`

​	아스키코드 (7bit, 128가지)를 입력받아 해당 문자를 출력

​	ascii : 미국 표준

```python
chr(65)
```

#### `divmod()`

​	나눈 몫과 나머지를 tuple로 출력

```python
res = divmod(6,4)
print(res[0])
```

#### `enumerate()`

​	순서가 있는 자료형 (list, tuple, 문자열)을 입력받아서 인덱스아 함께 자료를 리턴해주는 함수

```python
for idx, name in enumerate( ['test','text','body']) :
    print(idx, name)
    
for data in enumerate( ['test','text','body']) :
    print(data) # 쌍으로 묶여서 tuple로 출력
    print(data[0], data[1]) # 위 구문과 동일해짐
```

`eval()`

​	실행 가능한 문자열에 대해 실행한 결과를 리턴해주는 함수

```python
1+2 # 실행 가능한 숫자
"1+2" # 실행 가능한 문자열 (실행 가능하지만 문자열이라 연산이 안됨)

eval("1+2")
eval("'hi'+'hello'") # 따옴표 주의
```





## 딴소리(주제관련)

** 아파트관리비 세부 항목을 비교 분석 (공용관리비의 변화패턴 분석, 공용관리비 적정성 분석 등등)

** 챗봇 (HMM, Bayes기반, RNN(LSTM)기반)

** 날씨 / 미세먼지 분석



## 연습문제

#### Q1
다음과 같은 내용을 지닌 파일 test.txt가 있다. 이 파일의 내용 중 "java"라는 문자열을 "python"으로 바꾸어서 저장해 보자.

Life is too short

you need java

※ replace 함수를 사용해 보자.

```python
file = ['Life is too short', 'you need java']
with open('c:/da/test1.txt', 'w') as f: # 파일 생성
    for i in file :
        f.write(i+'\n')
        
with open('c:/da/test1.txt', 'r') as f_r:
  # 파일 읽은 후 java 부분 python으로 변경
    read = f_r.readlines()
    read[1] = read[1].replace('java','python')
   
with open('c:/da/test1.txt', 'w') as f:
    for i in read:
        f.write(i) # read list에 있는 부분 저장
        
print(read)
```



#### Q2
사용자의 입력을 파일(test.txt)에 저장하는 프로그램을 작성해 보자. 
(단 프로그램을 다시 실행하더라도 기존에 작성한 내용을 유지하고 새로 입력한 내용을 추가해야 한다.)

```python
text = input('text : ')

with open('c:/da/test.txt', 'a') as f:
    f.write(text+'\n')
```



#### Q3
다음은 Calculator 클래스이다.

```
class Calculator:
    def __init__(self):
        self.value = 0

    def add(self, val):
        self.value += val
```

위 클래스를 상속하는 UpgradeCalculator를 만들고 값을 뺄 수 있는 minus 메서드를 추가해 보자.
즉 다음과 같이 동작하는 클래스를 만들어야 한다.

```
cal = UpgradeCalculator()
cal.add(10)
cal.minus(7)
print(cal.value) # 10에서 7을 뺀 3을 출력
```

```python
class UpgradeCalculator(Calculator):
    def minus(self, val): # 마이너스 부분 추가
        self.value -= val

cal = UpgradeCalculator()
cal.add(10)
cal.minus(7)
print(cal.value)
```



#### Q4.
객체변수 value가 100 이상의 값은 가질 수 없도록 제한하는 MaxLimitCalculator 클래스를 만들어 보자. 즉 다음과 같이 동작해야 한다.

```
cal = MaxLimitCalculator()
cal.add(50) # 50 더하기
cal.add(60) # 60 더하기

print(cal.value) # 100 출력
단 반드시 다음과 같은 Calculator 클래스를 상속해서 만들어야 한다.

class Calculator:
    def __init__(self):
        self.value = 0

    def add(self, val):
        self.value += val
```

```python
class MaxLimitCalculator(Calculator):
    def add(self, val): # add 부분 수정
        self.value += val # 주어진 수와 계산한 후 계산 결과가 100보다 크면 계산 결과 100으로 고정
        if self.value >= 100:
            self.value = 100
            return
        else :
            return
        
cal = MaxLimitCalculator()
cal.add(50) # 50 더하기
cal.add(60) # 60 더하기

print(cal.value) # 100 출력
```



#### Q5.
map과 lambda를 사용하여 [1, 2, 3, 4] 리스트의 각 요솟값에 3이 곱해진 리스트 [3, 6, 9, 12]를 만들어 보자.

```python
n = [1,2,3,4]
result = list(map(lambda x : x*3, n))
print(result)
```



#### Q6.
지뢰찾기 게임은 M x N 매트릭스에 위치해 있는 지뢰를 찾는 게임이다.

M x N 매트릭스 상의 격자(square)는 지뢰이거나 지뢰가 아니다.

지뢰 격자는 *로 표시한다. 지뢰가 아닌 격자(square)는 숫자로 표시하며 그 숫자는 인접해 있는 지뢰의 수를 의미한다. (격자(sqaure)는 최대 8개의 인접한 지뢰를 가질 수 있다.)

다음은 4x4 매트릭스에서 2개의 지뢰(*)를 표시하는 방법이다.

```
*...
....
.*..
....
```

이 게임의 목표는 지뢰의 위치(*)를 제외한 나머지 격자들의 숫자를 맞추는 것이다.

위 경우의 답은 아래와 같다.

```
*100
2210
1*10
1110
```

첫번째 줄은 M x N 의 M(행)과 N(열)에 해당되는 숫자이다. N과 M은 0보다 크고 100 이하이다. (0< N, M <=100) 그 다음 M개의 줄이 차례로 입력되고 각 줄은 정확하게 N개의 문자가 입력된다. 지뢰 격자는 *로 표시하며 지뢰가 아닌 격자는 .(dot)로 표시한다.

출력

지뢰(*)를 제외한 나머지 격자의 숫자값을 찾아서 M x N 매트릭스를 출력한다.

```python
# 답

def make_matrix(m,n): # 주어진 행*열 m*n값을 가지고 무작위로 지뢰 만드는 함수
    bomb = ['.','*']
    n_matrix = []
    for x in range(0,n):
        n_matrix.append(['*']*m) # '*'으로 구성된 n_matrix 생성

    for x in range(0,n):
        for y in range(0,m):
            n_matrix[x][y] = random.choice(bomb) # '*'자리에 랜덤으로 '.' 대체 후 지뢰가 있는 n_matrix 완성
    for i in n_matrix:
        print("".join(i)) # 보기 좋은 형태로 출력
    print('\n')
    return n_matrix

def find_bomb(m,n,n_matrix): # m,n과 생성된 매트릭스 값을 가지고 근접한 지뢰를 찾아내는 함수
    for x in range(0,n):
        for y in range(0,m):
            bomb_count = 0 # 근접한 지뢰 수 세는 변수 생성
            if n_matrix[x][y] != '*': # 지뢰가 아니면 근접한 지뢰 수를 카운트하기 시작
                bomb_count_li = [(x-1,y-1), (x-1,y), (x-1,y+1), (x, y-1),(x,y+1),(x+1,y-1),(x+1,y), (x+1,y+1)]
                # 근접한 곳의 좌표
                for i in bomb_count_li :
                    try: # 근접한 곳 8곳이 모두 있지 않을 수 있으므로 오류문구 무시하는 try-except 문 설정
                        a = n_matrix[i[0]][i[1]]
                        if a == '*':
                            bomb_count += 1 # 해당 좌표에 '*'지뢰가 있으면 bomb_count 1씩 증가
                        else : pass
                    except :
                        bomb_count = 0
                n_matrix[x][y] = str(bomb_count) # 좌표에 '.'대신 bomb_count 넣기
            else :
                pass
    return n_matrix # 매트릭스 완성


if __name__ == "__main__":
    
    M = input('행의 값을 입력해주세요 : ')
    N = input('열의 값을 입력해주세요 : ')
    m = int(M)
    n = int(N)
    
    print('\n')

    new_matrix = make_matrix(m,n) # 랜덤 지뢰 생성 함수
#    new_matrix = [['*','.','.','.'],['.','.','.','.'],['.','*','.','.'],['.','.','.','.']]
# 예시 출력 matrix
    last_matrix = find_bomb(m,n,new_matrix) # 근접한 지뢰 카운팅 함수
    
    for i in n_matrix:
        print("".join(i)) # 보기 좋게 print
```

